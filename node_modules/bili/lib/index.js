'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _util = require('util');

var _util2 = _interopRequireDefault(_util);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _globby = require('globby');

var _globby2 = _interopRequireDefault(_globby);

var _chalk = require('chalk');

var _chalk2 = _interopRequireDefault(_chalk);

var _rollup = require('rollup');

var _readPkgUp = require('read-pkg-up');

var _readPkgUp2 = _interopRequireDefault(_readPkgUp);

var _camelcase = require('camelcase');

var _camelcase2 = _interopRequireDefault(_camelcase);

var _prettyBytes = require('pretty-bytes');

var _prettyBytes2 = _interopRequireDefault(_prettyBytes);

var _gzipSize = require('gzip-size');

var _gzipSize2 = _interopRequireDefault(_gzipSize);

var _stringWidth = require('string-width');

var _stringWidth2 = _interopRequireDefault(_stringWidth);

var _boxen = require('boxen');

var _boxen2 = _interopRequireDefault(_boxen);

var _rollupPluginNodeResolve = require('rollup-plugin-node-resolve');

var _rollupPluginNodeResolve2 = _interopRequireDefault(_rollupPluginNodeResolve);

var _rollupPluginCommonjs = require('rollup-plugin-commonjs');

var _rollupPluginCommonjs2 = _interopRequireDefault(_rollupPluginCommonjs);

var _rollupPluginJson = require('rollup-plugin-json');

var _rollupPluginJson2 = _interopRequireDefault(_rollupPluginJson);

var _rollupPluginUglify = require('rollup-plugin-uglify');

var _rollupPluginUglify2 = _interopRequireDefault(_rollupPluginUglify);

var _rollupPluginAlias = require('rollup-plugin-alias');

var _rollupPluginAlias2 = _interopRequireDefault(_rollupPluginAlias);

var _rollupPluginReplace = require('rollup-plugin-replace');

var _rollupPluginReplace2 = _interopRequireDefault(_rollupPluginReplace);

var _rollupPluginHashbang = require('rollup-plugin-hashbang');

var _rollupPluginHashbang2 = _interopRequireDefault(_rollupPluginHashbang);

var _textTable = require('text-table');

var _textTable2 = _interopRequireDefault(_textTable);

var _template = require('./template');

var _template2 = _interopRequireDefault(_template);

var _getBanner = require('./get-banner');

var _getBanner2 = _interopRequireDefault(_getBanner);

var _getConfig = require('./get-config');

var _biliError = require('./bili-error');

var _biliError2 = _interopRequireDefault(_biliError);

var _handleError = require('./handle-error');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

const FORMATS = ['cjs'];

class Bili {
  static generate(options) {
    return _asyncToGenerator(function* () {
      const bundle = yield new Bili(options).bundle({ write: false });
      return bundle;
    })();
  }

  static write(options) {
    return _asyncToGenerator(function* () {
      const bundle = yield new Bili(options).bundle();

      if (!options.watch) {
        console.log((yield bundle.stats()));
      }

      return bundle;
    })();
  }

  static handleError(err) {
    return (0, _handleError.handleError)(err);
  }

  constructor(options = {}) {
    this.options = Object.assign({
      outDir: 'dist',
      filename: '[name][suffix].js',
      uglifyEs: true,
      cwd: process.cwd()
    }, options);
    this.bundles = {};
  }

  stats() {
    var _this = this;

    return _asyncToGenerator(function* () {
      const bundles = _this.bundles;

      const sizes = yield Promise.all(Object.keys(bundles).sort().map((() => {
        var _ref = _asyncToGenerator(function* (filepath) {
          var _bundles$filepath = bundles[filepath];
          const code = _bundles$filepath.code,
                relative = _bundles$filepath.relative;

          return [relative, (0, _prettyBytes2.default)(code.length), _chalk2.default.green((0, _prettyBytes2.default)((yield (0, _gzipSize2.default)(code))))];
        });

        return function (_x) {
          return _ref.apply(this, arguments);
        };
      })()));

      return (0, _boxen2.default)((0, _textTable2.default)([['file', 'size', 'gzip size'].map(function (v) {
        return _chalk2.default.bold(v);
      }), ...sizes], {
        stringLength: _stringWidth2.default
      }));
    })();
  }

  getArrayOption(name) {
    const option = this.options[name] || this.options[`${name}s`];
    if (typeof option === 'string') return option.split(',');
    return option;
  }

  resolveCwd(...args) {
    return _path2.default.resolve(this.options.cwd, ...args);
  }

  relativeToProcessCwd(...args) {
    return _path2.default.relative(process.cwd(), this.resolveCwd(...args));
  }

  loadUserPlugins({ filename }) {
    const plugins = this.getArrayOption('plugin') || [];
    // eslint-disable-next-line array-callback-return
    return plugins.map(pluginName => {
      // In bili.config.js or you're using the API
      // You can require rollup plugin directly
      if (typeof pluginName === 'object') {
        return pluginName;
      }

      let pluginOptions = this.options[pluginName];
      if (pluginName === 'vue') {
        pluginOptions = Object.assign({
          css: _path2.default.resolve(this.options.outDir, filename.replace(/\.[^.]+$/, '.css'))
        }, pluginOptions);
      } else if (pluginName === 'postcss') {
        pluginOptions = Object.assign({
          extract: true
        }, pluginOptions);
      }
      const moduleName = `rollup-plugin-${pluginName}`;
      try {
        // TODO:
        // Local require is always relative to `process.cwd()`
        // Instead of `this.options.cwd`
        // We need to ensure that which is actually better
        return localRequire(moduleName)(pluginOptions);
      } catch (err) {
        handleLoadPluginError(moduleName, err);
      }
    });
  }

  createConfig({ input, format, compress }) {
    var _this2 = this;

    return _asyncToGenerator(function* () {
      const options = _this2.options.extendOptions ? _this2.options.extendOptions(_this2.options, {
        input,
        format,
        compress
      }) : _this2.options;

      if (typeof options !== 'object') {
        throw new _biliError2.default('You must return the options in `extendOptions` method!');
      }

      const outDir = options.outDir,
            filename = options.filename;
      var _options$inline = options.inline;
      const inline = _options$inline === undefined ? format === 'umd' : _options$inline;


      const outFilename = getFilename({
        input,
        format,
        filename,
        compress,
        name: options.name
      });
      // The path to output file
      // Relative to `this.options.cwd`
      const file = _this2.resolveCwd(outDir, outFilename);

      const transformJS = options.js !== false;
      const jsPluginName = transformJS && (options.js || 'buble');
      const jsPlugin = transformJS && getJsPlugin(jsPluginName);
      const jsOptions = transformJS && getJsOptions(jsPluginName, options.jsx, options[jsPluginName]);

      const banner = (0, _getBanner2.default)(options.banner, _this2.pkg);

      let external = _this2.getArrayOption('external') || [];
      external = external.map(function (e) {
        return e.startsWith('./') ? _path2.default.resolve(e) : e;
      });
      let globals = options.globals || options.global;
      if (typeof globals === 'object') {
        external = [...external, ...Object.keys(globals)];
      }

      const inputOptions = {
        input,
        external,
        onwarn: function onwarn({ loc, frame, message, code }) {
          if (options.quiet || code === 'UNRESOLVED_IMPORT' || code === 'THIS_IS_UNDEFINED') {
            return;
          }
          // print location if applicable
          if (loc) {
            console.warn(`${loc.file} (${loc.line}:${loc.column}) ${message}`);
            if (frame) console.warn(_chalk2.default.dim(frame));
          } else {
            console.warn('ðŸ™‹â€â™‚ï¸ ', message);
          }
        },
        plugins: [(0, _rollupPluginHashbang2.default)(), ..._this2.loadUserPlugins({ filename: outFilename }), transformJS && jsPluginName === 'buble' && require('rollup-plugin-babel')({
          babelrc: false,
          exclude: 'node_modules/**',
          presets: [[require.resolve('./babel'), {
            buble: true,
            jsx: options.jsx,
            objectAssign: jsOptions.objectAssign
          }]]
        }), transformJS && jsPlugin(Object.assign({
          exclude: 'node_modules/**'
        }, jsOptions)), inline && (0, _rollupPluginCommonjs2.default)(), inline && (0, _rollupPluginNodeResolve2.default)({
          module: true
        }), (0, _rollupPluginJson2.default)(), compress && (0, _rollupPluginUglify2.default)(Object.assign({}, options.uglify, {
          output: Object.assign({}, options.uglify && options.uglify.output, {
            // Add banner (if there is)
            preamble: banner
          })
        }), options.uglifyEs ? require('uglify-es').minify : undefined), options.alias && (0, _rollupPluginAlias2.default)(options.alias), options.replace && (0, _rollupPluginReplace2.default)(options.replace), {
          name: 'bili',
          ongenerate: function ongenerate(_, { code }) {
            _this2.bundles[file] = {
              relative: _path2.default.relative(_path2.default.resolve(outDir, '..'), file),
              input,
              format,
              compress,
              code
            };
          }
        }, options.env && (0, _rollupPluginReplace2.default)({
          values: Object.keys(options.env).reduce(function (res, key) {
            res[`process.env.${key}`] = JSON.stringify(options.env[key]);
            return res;
          }, {})
        })].filter(function (v) {
          return Boolean(v);
        })
      };

      const outputOptions = {
        format,
        globals,
        name: format === 'umd' && _this2.getModuleName(),
        file,
        banner,
        exports: options.exports,
        sourcemap: typeof options.map === 'boolean' ? options.map : compress
      };

      return {
        inputOptions,
        outputOptions
      };
    })();
  }

  bundle({ write = true } = {}) {
    var _this3 = this;

    return _asyncToGenerator(function* () {
      _this3.pkg = yield (0, _readPkgUp2.default)({ cwd: _this3.options.cwd }).then(function (res) {
        return res.pkg || {};
      });

      let inputFiles = _this3.options.input || 'src/index.js';
      if (Array.isArray(inputFiles) && inputFiles.length === 0) {
        inputFiles = 'src/index.js';
      }

      inputFiles = yield (0, _globby2.default)(inputFiles, { cwd: _this3.options.cwd }).then(function (res) {
        return res.map(function (v) {
          return _this3.relativeToProcessCwd(v);
        });
      });

      if (inputFiles.length === 0) {
        throw new _biliError2.default('No matched files to bundle.');
      }

      const formats = _this3.getArrayOption('format') || FORMATS;

      const options = inputFiles.reduce(function (res, input) {
        return [...res, ...formats.map(function (format) {
          const compress = format.endsWith('-min');
          return {
            input,
            format: format.replace(/-min$/, ''),
            compress
          };
        })];
      }, []);

      const actions = options.map((() => {
        var _ref2 = _asyncToGenerator(function* (option) {
          var _ref3 = yield _this3.createConfig(option);

          const inputOptions = _ref3.inputOptions,
                outputOptions = _ref3.outputOptions;


          if (_this3.options.watch) {
            const watcher = (0, _rollup.watch)(Object.assign({}, inputOptions, {
              output: outputOptions,
              watch: {
                clearScreen: true
              }
            }));
            watcher.on('event', (() => {
              var _ref4 = _asyncToGenerator(function* (e) {
                if (e.code === 'ERROR' || e.code === 'FATAL') {
                  (0, _handleError.handleError)(e.error);
                }
                if (e.code === 'BUNDLE_END') {
                  process.exitCode = 0;
                  console.log(`${e.input} -> ${_path2.default.relative(_path2.default.resolve(_this3.options.outDir || 'dist', '..'), outputOptions.file)}`);
                }
              });

              return function (_x3) {
                return _ref4.apply(this, arguments);
              };
            })());
            return;
          }

          if (_this3.options.inspectRollup) {
            console.log(_chalk2.default.bold(`Rollup input options for bundling ${option.input} in ${option.format}:\n`), _util2.default.inspect(inputOptions, { colors: true }));
            console.log(_chalk2.default.bold(`Rollup output options for bundling ${option.input} in ${option.format}:\n`), _util2.default.inspect(outputOptions, { colors: true }));
          }

          const bundle = yield (0, _rollup.rollup)(inputOptions);
          if (write) return bundle.write(outputOptions);
          return bundle.generate(outputOptions);
        });

        return function (_x2) {
          return _ref2.apply(this, arguments);
        };
      })());
      yield Promise.all(actions);

      // Since we update `this.bundles` in Rollup plugin's `ongenerate` callback
      // We have to put follow code into another callback to execute at th end of call stack
      yield nextTick(function () {
        if (Object.keys(_this3.bundles).length < formats.length * inputFiles.length) {
          const hasName = _this3.options.filename.includes('[name]');
          const hasSuffix = _this3.options.filename.includes('[suffix]');
          const msg = `Multiple files are emitting to the same path.\nPlease check if ${hasName || inputFiles.length === 1 ? '' : `${_chalk2.default.green('[name]')}${hasSuffix ? '' : ' or '}`}${hasSuffix ? '' : _chalk2.default.green('[suffix]')} is missing in ${_chalk2.default.green('filename')} option.\n${(0, _handleError.getDocRef)('api', 'filename')}`;
          throw new _biliError2.default(msg);
        }
      });

      return _this3;
    })();
  }

  getModuleName() {
    return this.options.moduleName || this.pkg.moduleName || this.pkg.name && (0, _camelcase2.default)(this.pkg.name);
  }
}

exports.default = Bili;
function getSuffix(format) {
  let suffix = '';
  switch (format) {
    case 'cjs':
      suffix += '.cjs';
      break;
    case 'umd':
      break;
    case 'es':
      suffix += '.m';
      break;
    default:
      throw new Error('unsupported format');
  }
  return suffix;
}

function getNameFromInput(input) {
  return _path2.default.basename(input, _path2.default.extname(input));
}

function getFilename({ input, format, filename, compress, name }) {
  name = name || getNameFromInput(input);
  const suffix = getSuffix(format);
  const res = (0, _template2.default)(filename, { name, suffix });
  return compress ? _path2.default.basename(res, _path2.default.extname(res)) + '.min' + _path2.default.extname(res) : res;
}

function getJsOptions(name, jsx, jsOptions) {
  if (name === 'babel') {
    return Object.assign({
      babelrc: !process.env.BILI_TEST
    }, (0, _getConfig.getBabelConfig)({ jsx }), jsOptions);
  }

  if (name === 'buble') {
    return Object.assign({}, jsOptions, {
      transforms: Object.assign({
        dangerousForOf: true,
        dangerousTaggedTemplateString: true
      }, jsOptions && jsOptions.transforms)
    });
  }

  if (name === 'typescript') {
    let typescript;
    try {
      typescript = localRequire('typescript');
    } catch (err) {}
    return Object.assign({
      typescript
    }, jsOptions);
  }

  return {};
}

function getJsPlugin(name) {
  const req = name === 'babel' || name === 'buble' ? require : localRequire;
  const moduleName = `rollup-plugin-${name}`;
  try {
    return req(moduleName);
  } catch (err) {
    handleLoadPluginError(moduleName, err);
  }
}

function localRequire(name) {
  return require(_path2.default.resolve('node_modules', name));
}

function handleLoadPluginError(moduleName, err) {
  if (err.code === 'MODULE_NOT_FOUND' && err.message.includes(moduleName)) {
    throw new _biliError2.default(`Cannot find plugin "${moduleName}" in current directory!\n${_chalk2.default.dim(`You may run "npm install -D ${moduleName}" to install it.`)}`);
  } else {
    throw err;
  }
}

function nextTick(fn) {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      try {
        fn();
        resolve();
      } catch (err) {
        reject(err);
      }
    });
  });
}